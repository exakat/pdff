<?php declare(strict_types=1);

use ast\flags;
use Exakat\Reports\Helpers\PdffClass;
use Exakat\Reports\Helpers\PdffTrait;
use Exakat\Reports\Helpers\PdffInterface;
use Exakat\Reports\Helpers\PdffExtends;
use Exakat\Reports\Helpers\PdffPhpdoc;
use Exakat\Reports\Helpers\PdffAttribute;
use Exakat\Reports\Helpers\PdffConstant;
use Exakat\Reports\Helpers\PdffFunction;
use Exakat\Reports\Helpers\PdffTypehint;
use Exakat\Reports\Helpers\PdffParameter;
use Exakat\Reports\Helpers\PdffMethod;
use Exakat\Reports\Helpers\PdffClassConstant;
use Exakat\Reports\Helpers\PdffProperty;

include 'scripts/Pdff.php';

const AST_DUMP_LINENOS = 1;
const AST_DUMP_EXCLUDE_DOC_COMMENT = 2;

const TYPES = [
ast\flags\TYPE_ARRAY		=> '\array',
ast\flags\TYPE_CALLABLE		=> '\callable',
ast\flags\TYPE_VOID		 	=> '\void',
ast\flags\TYPE_BOOL		 	=> '\bool',
ast\flags\TYPE_LONG			=> '\int',
ast\flags\TYPE_DOUBLE		=> '\float',
ast\flags\TYPE_STRING		=> '\string',
ast\flags\TYPE_ITERABLE		=> '\iterable',
ast\flags\TYPE_OBJECT		=> '\object',
ast\flags\TYPE_NULL		 	=> '\null',
ast\flags\TYPE_FALSE		=> '\true',
ast\flags\TYPE_STATIC		=> '\static',
ast\flags\TYPE_MIXED		=> '\mixed',
ast\flags\TYPE_NEVER  		=> '\never',
];

$b = hrtime(true);
$code = file_get_contents('test.php');
//$code = file_get_contents('scripts/Pdff.php');

//var_dump(ast\parse_code($code, $version=90));
//echo ast_dump(ast\parse_code($code, $version=70)), "\n";

$ast = ast\parse_code($code, $version=90);
$pdff = new Exakat\Reports\Helpers\Pdff();
$version = $pdff->setVersion();
$version->setNamespace('\\');

toPdff($ast, $pdff);

print json_encode($pdff->toArray(), JSON_PRETTY_PRINT);
$e = hrtime(true);

print PHP_EOL.number_format(($e - $b) / 1000000, 2)." ms\n";

function toPdff($ast, $pdff) {
	switch($ast->kind) {
		case ast\AST_STMT_LIST:
			foreach($ast->children as $child) {
				toPdff($child, $pdff);
			}
			break;

		case ast\AST_CONST_DECL:
			toPdffConst($ast, $pdff);
			break;

		case ast\AST_FUNC_DECL:
			toPdffFunction($ast, $pdff);
			break;

		case ast\AST_CLASS:
			switch(true) {
				case $ast->flags & ast\flags\CLASS_INTERFACE:
					toPdffInterface($ast, $pdff);
					break;

				case $ast->flags & ast\flags\CLASS_TRAIT:
					toPdffTrait($ast, $pdff);
					break;

				default:
					toPdffClass($ast, $pdff);
			}
			break;

		case ast\AST_DECLARE:
		case ast\AST_NAMESPACE: // @todo
			// continue;
			break;
			
		default:
			print "No processing for ".ast\get_kind_name($ast->kind).PHP_EOL;
			die();
	}
}

function toPdffClass($ast, $pdff) {
	$version = $pdff->getVersion();
	$ns = $version->getNamespace();
	
	$theClass = new PdffClass($ast->children['name'],
							 (bool) ($ast->flags & ast\flags\MODIFIER_ABSTRACT),
							 (bool) ($ast->flags & ast\flags\MODIFIER_FINAL),
							 false, //this is $readonly,
							 getName($ast->children['extends'])
							 );

	foreach($ast->children['stmts']->children as $cm) {
		switch ($cm->kind) {
			case ast\AST_METHOD:
				toPdffMethod($cm, $theClass);
				break;

			case ast\AST_PROP_GROUP:
				foreach($cm->children['props']->children as $property) {
					toPdffProperty($property, $theClass, $cm->flags, $cm->children['type']);
				}
				break;

			case ast\AST_CLASS_CONST_GROUP:
				foreach($cm->children['const']->children as $const) {
					toPdffClassConst($const, $theClass, $cm->flags);
				}
				break;

			case ast\AST_USE_TRAIT:
//				print_r($cm);die();
				foreach($cm->children['traits']->children as $usetrait) {
					toPdffUseTrait($usetrait, $theClass);
				}
				break;

			default:
				print "New structure in Class : ".ast\get_kind_name($cm->kind);
				break;
				
		}
	}
							 
	addImplements ($theClass, $ast->children['implements']->children ?? array());
	addDoccomments($theClass, $ast->children['docComment']);
	addAttributes ($theClass, $ast->children['attributes']);

	$ns->addClass($ast->children['name'], $theClass);
}

function toPdffConst($ast, $pdff) {
	$version = $pdff->getVersion();
	$ns = $version->getNamespace();
	
	foreach($ast->children as $const) {
    	$theConstant = new PdffConstant($const->children['name'],
        	                            (string) $const->children['value'],
            	                        false
                	                    );    

		addDoccomments($theConstant, $const->children['docComment']);

	    $ns->addConstant($const->children['name'], $theConstant);
	}
}

function toPdffFunction($ast, $pdff) {
	$version = $pdff->getVersion();
	$ns = $version->getNamespace();

    $theFunction = new PdffFunction($ast->children['name'],
    								is_array($ast->children['returnType']) ? 'or' : 'one', // array => union, sinon simple
        	                        (bool) ($ast->flags & ast\flags\FUNC_RETURNS_REF)
            	                    );    

	addDoccomments($theFunction, $ast->children['docComment']);

	if ($ast->children['returnType'] !== null) {
		addTypes($theFunction, isset($ast->children['returnType']->children[0]) ? $ast->children['returnType']->children : array($ast->children['returnType']));
	}

    addParameters($ast->children['params'], $theFunction);

	$ns->addFunction($ast->children['name'], $theFunction);
}

function toPdffInterface($ast, $pdff) {
	$version = $pdff->getVersion();
	$ns = $version->getNamespace();
	
	$theInterface = new PdffInterface($ast->children['name'],
									  getName($ast->children['extends'])
									  );

	$ns->addInterface($ast->children['name'], $theInterface);

	foreach($ast->children['stmts']->children as $cm) {
		switch ($cm->kind) {
			case ast\AST_METHOD:
				toPdffMethod($cm, $theInterface);
				break;

			case ast\AST_CLASS_CONST_GROUP:
				foreach($cm->children['const']->children as $const) {
					toPdffClassConst($const, $theInterface, $cm->flags);
				}
				break;

			default:
				print "New structure in CITE : ".ast\get_kind_name($cm->kind);
				break;
				
		}
	}									  
}

function getVisibility($flag) {
	if ($flag & ast\flags\MODIFIER_PRIVATE) {
		return 'private';
	}

	if ($flag & ast\flags\MODIFIER_PROTECTED) {
		return 'protected';
	}

	if ($flag & ast\flags\MODIFIER_PUBLIC) {
		return 'public';
	}

	return 'none';
}

function getTypehintType($type) : string {
	return is_array($type) ? 'or' : 'one';
}

function toPdffClassConst($ast, $pdff, $flags) {
        $theClassConstant = new PdffClassConstant($ast->children['name'],
                                                  (string) $ast->children['value'],
                                                  false, // Not an expression
                                                  getVisibility($flags),
                                                  (bool) ($flags & ast\flags\MODIFIER_FINAL),
                                                 );

		addDoccomments($theClassConstant, $ast->children['docComment']);
		addAttributes($theClassConstant,  $ast->children['attributes']);

        $pdff->addClassConstant($ast->children['name'], $theClassConstant);
}

function toPdffProperty($ast, $pdff, $flags, $types) {
        $theProperty = new PdffProperty('$'.$ast->children['name'],
                                        getVisibility($flags),
                                        (string) $ast->children['default'],
                                        !empty($ast->children['default']), // hasDefault
                                        false, // Not an expression
                                        (bool) ($flags & ast\flags\MODIFIER_STATIC),
                                        false, // readonly (bool) ($flags & ast\flags\MODIFIER_STATIC),
                                        getTypehintType($types),
                                        false // var
                                    );

		addDoccomments($theProperty, $ast->children['docComment']);

        $pdff->addProperty('$'.$ast->children['name'], $theProperty);
}

function toPdffUseTrait($ast, $pdff) {
        $theUse = new PdffExtends($ast->children['name']);

        $pdff->addUse($theUse, array());
}

function toPdffMethod($ast, $pdff) {
	$theMethod = new PdffMethod($ast->children['name'],
	                            getVisibility($ast->flags),
	                            (bool) ($ast->flags & ast\flags\MODIFIER_PROTECTED),
	                            (bool) ($ast->flags & ast\flags\MODIFIER_STATIC),
	                            (bool) ($ast->flags & ast\flags\RETURNS_REF),
	                            getTypehintType($ast->children['returnType']),
	                            );

	addDoccomments($theMethod, $ast->children['docComment']);
	addParameters($theMethod,  $ast->children['params']);
	if ($ast->children['returnType'] !== null) {
		addTypes($theMethod, isset($ast->children['returnType']->children[0]) ? $ast->children['returnType']->children : array($ast->children['returnType']));
	}
	
	$pdff->addMethod($ast->children['name'], $theMethod);
}

function toPdffTrait($ast, $pdff) {
	$version = $pdff->getVersion();
	$ns = $version->getNamespace();
	
	$theTrait = new PdffTrait($ast->children['name'],
								  getName($ast->children['extends'])
								  );

	foreach($ast->children['stmts']->children as $cm) {
		switch ($cm->kind) {
			case ast\AST_METHOD:
				toPdffMethod($cm, $theTrait);
				break;

			case ast\AST_PROP_GROUP:
				foreach($cm->children['props']->children as $property) {
					toPdffProperty($property, $theTrait, $cm->flags, $cm->children['type']);
				}
				break;

			default:
				print "New structure in Trait : ".ast\get_kind_name($cm->kind);
				break;
				
		}
	}	

	addDoccomments($theTrait, $ast->children['docComment']);

	$ns->addTrait($ast->children['name'], $theTrait);
}

function addParameters($ast, $theFunction) {
	if (empty($ast->children)) {
		return;
	}

	foreach($ast->children as $position => $param) {
	    $theParameter = new PdffParameter($param->children['name'],
    	                                  $position,
    	                                  (bool) ($param->flags & ast\flags\PARAM_VARIADIC),
    	                                  (bool) ($param->flags & ast\flags\PARAM_REF),
    	                                  $param->children['default'] === null,  // @todo : handle variations
                    	               	  (string) $param->children['default'], //  $default,
                        	           	  false, 			// @todo : when is this an expression?
		                                  getTypehintType($param->children['type']),
                                	   );

	    $theFunction->addParameter($position, $theParameter);
		if ($ast->children['returnType'] !== null) {
			addTypes($theParameter, isset($param->children['type']->children[0]) ? $param->children['type']->children : array($param->children['type']->children));
		}
	}
}

function addImplements($theClass, $implements) {
	foreach($implements as $implement) {
		$theImplement = new PdffExtends(getName($implement));

        $theClass->addImplements($theImplement, array()); // @todo add support for local aliases
	}
}

function addTypes($theClass, $types) {
	if (empty($types)) {
		return;
	}

	foreach($types as $type) {
		// @todo : handle case of object with classes (not \\object) : otherwise, tjey are null
		$theType = new PdffTypehint(\TYPES[$type->flags]);
	
		$theClass->addTypehint($theType);
	}
}

function addDoccomments($theClass, $doccomments) {
	if (empty($doccomments)) { return; }

	$thePhpdoc = new PdffPhpdoc($doccomments);

    $theClass->addPhpdoc($thePhpdoc);
}

function addAttributes($theClass, $attributes) {
	if (empty($attributes->children)) { return; }

	foreach($attributes->children as $attribute) {
		// @todo : build the attribute with arguments and sub expressions
		$theAttribute = new PdffAttribute(getName($attribute->children[0]->children['class']));

    	$theClass->addAttribute($theAttribute);
	}
}

function getName($node) {
	return $node->children['name'] ?? '';
}

function get_flag_info() : array {
    static $info;
    if ($info !== null) {
        return $info;
    }

    foreach (ast\get_metadata() as $data) {
        if (empty($data->flags)) {
            continue;
        }

        $flagMap = [];
        foreach ($data->flags as $fullName) {
            $shortName = substr($fullName, strrpos($fullName, '\\') + 1);
            $flagMap[constant($fullName)] = $shortName;
        }

        $info[(int) $data->flagsCombinable][$data->kind] = $flagMap;
    }

    return $info;
}

function format_flags(int $kind, int $flags) : string {
    list($exclusive, $combinable) = get_flag_info();
    if (isset($exclusive[$kind])) {
        $flagInfo = $exclusive[$kind];
        if (isset($flagInfo[$flags])) {
            return "{$flagInfo[$flags]} ($flags)";
        }
    } else if (isset($combinable[$kind])) {
        $flagInfo = $combinable[$kind];
        $names = [];
        foreach ($flagInfo as $flag => $name) {
            if ($flags & $flag) {
                $names[] = $name;
            }
        }
        if (!empty($names)) {
            return implode(" | ", $names) . " ($flags)";
        }
    }
    return (string) $flags;
}

/** Dumps abstract syntax tree */
function ast_dump($ast, int $options = 0) : string {
    if ($ast instanceof ast\Node) {
        $result = ast\get_kind_name($ast->kind);

        if ($options & AST_DUMP_LINENOS) {
            $result .= " @ $ast->lineno";
            if (isset($ast->endLineno)) {
                $result .= "-$ast->endLineno";
            }
        }

        if (ast\kind_uses_flags($ast->kind) || $ast->flags != 0) {
            $result .= "\n    flags: " . format_flags($ast->kind, $ast->flags);
        }
        foreach ($ast->children as $i => $child) {
            if (($options & AST_DUMP_EXCLUDE_DOC_COMMENT) && $i === 'docComment') {
                continue;
            }
            $result .= "\n    $i: " . str_replace("\n", "\n    ", ast_dump($child, $options));
        }
        return $result;
    } else if ($ast === null) {
        return 'null';
    } else if (is_string($ast)) {
        return "\"$ast\"";
    } else {
        return (string) $ast;
    }
}

?>